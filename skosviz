#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2011-2015 Reece H. Dunn
#
# This file is part of skosviz.
#
# skosviz is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# skosviz is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with skosviz.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import codecs
import subprocess

from xml.dom import minidom

class RdfNamespace:
	def __init__(self, ns):
		self.ns = ns

	def __getattr__(self, name):
		return (self.ns, name)

rdf  = RdfNamespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
dc   = RdfNamespace('http://purl.org/dc/elements/1.1/')
skos = RdfNamespace('http://www.w3.org/2004/02/skos/core#')

def parse_rdf(filename, input_format=None):
	with open(filename, 'rb') as f:
		srcdata = f.read()

	if not input_format:
		if srcdata.startswith(b'#') or srcdata.startswith(b'@prefix'):
			input_format = 'turtle'
		elif srcdata.startswith(b'<!--') or srcdata.startswith(b'<?xml'):
			input_format = 'rdfxml'
		else:
			input_format = 'ntriples'

	if input_format == 'rdfxml':
		return minidom.parseString(srcdata).documentElement

	rapper = subprocess.Popen(['rapper', '-', filename, '--input', input_format, '--output', 'rdfxml-abbrev'], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
	stdout, stderr = rapper.communicate(input=srcdata)
	return minidom.parseString(stdout).documentElement

# SKOS Object Model

class ConceptNode:
	def __init__(self, ref, name, alt, children):
		self.ref       = ref
		self.name      = name
		self.alt       = alt
		self.children  = children
		self.parent    = None
		self.relations = []

	def add_relations(self, rel, items):
		for item in items:
			self.relations.append((rel, item))

	def __str__(self):
		if len(self.alt) == 0:
			return self.name
		else:
			return '%s [%s]' % (self.name, ', '.join(self.alt))

class SkosLibrary:
	def __init__(self):
		self.refs = {}

# RDF/XML+SKOS Parser

def text(parent):
	for node in parent.childNodes:
		if node.nodeType == node.TEXT_NODE:
			return node.nodeValue
	return ''

def select(parent, ref):
	ret = []
	ns, name = ref
	for node in parent.childNodes:
		if node.nodeType == node.ELEMENT_NODE and node.localName == name and node.namespaceURI == ns:
			ret.append(node)
	return ret

def select_any(parent, *refs):
	for ref in refs:
		ret = select(parent, ref)
		if len(ret) != 0:
			return ret

def select_all(parent, *refs):
	for ref in refs:
		for ret in select(parent, ref):
			yield ret

def attr(parent, ref):
	ns, name = ref
	return parent.getAttributeNS(ns, name)

def getref(c):
	idref = attr(c, rdf.ID)
	if idref:
		return '#%s' % idref
	return attr(c, rdf.about)

def parse_skos(filename):
	ret  = SkosLibrary()
	dom  = parse_rdf(filename)
	for c in select(dom, skos.Concept):
		ref        = getref(c)
		name       = text(select(c, skos.prefLabel)[0])
		alt        = [text(a) for a in select_all(c, skos.altLabel, skos.notation)]
		children   = [attr(a, rdf.resource) for a in select(c, skos.narrower)]
		node = ret.refs[ref] = ConceptNode(ref, name, alt, children)
		node.add_relations('exactMatch', [attr(a, rdf.resource) for a in select(c, skos.exactMatch)])
	for c in select(dom, skos.ConceptScheme):
		ref      = getref(c)
		name     = text(select_any(c, dc.title, skos.prefLabel)[0])
		children = [attr(a, rdf.resource) for a in select(c, skos.hasTopConcept)]
		ret.refs[ref] = ConceptNode(ref, name, [], children)
		for n in children:
			ret.refs[n].parent = ref
	for ref, c in ret.refs.items():
		for n in c.children:
			ret.refs[n].parent = ref
	return ret

# Text Formatter

def tree_viz_node(c, padding, options, end):
	if end:
		branch = u'└─'
	else:
		branch = u'├─'
	options['output'].write(u'%s%s%s\n' % (padding, branch, c))

def tree_viz_impl(skos, c, padding, options, end=False):
	tree_viz_node(c, padding[:-1], options, end=end)
	padding = padding + ' '
	for i, child in enumerate(sorted(c.children, key=lambda c: skos.refs[c].name)):
		n = skos.refs[child]
		if len(n.children) != 0:
			if i == len(c.children)-1:
				tree_viz_impl(skos, n, padding + ' ', options, end=True)
			else:
				tree_viz_impl(skos, n, padding + u'│', options)
		else:
			tree_viz_node(n, padding, options, end=i == len(c.children)-1)

def tree_viz(skos, roots, options):
	for i, c in enumerate(sorted(roots, key=lambda c: c.name)):
		tree_viz_impl(skos, c, ' ', options, end=i == len(roots)-1)

# Dot Formatter

colours = {
	'exactMatch': 'blue',
}

def dot_viz_impl(skos, c, options):
	options['output'].write('\t"%s" [label="%s"]\n' % (c.ref, c.name.replace(' ', '\\n')))
	for i, child in enumerate(sorted(c.children, key=lambda c: skos.refs[c].name)):
		n = skos.refs[child]
		options['output'].write('\t"%s" -> "%s"\n' % (c.ref, n.ref))
	for i, (t, child) in enumerate(sorted(c.relations, key=lambda c: skos.refs[c[1]].name)):
		n = skos.refs[child]
		options['output'].write('\t"%s" -> "%s" [color=%s]\n' % (c.ref, n.ref, colours[t]))

def dot_viz(skos, roots, options):
	options['output'].write('digraph "SKOS Visualisation" {\n')
	for c in sorted(skos.refs.values(), key=lambda c: c.name):
		dot_viz_impl(skos, c, options)
	options['output'].write('}\n')

# Main Program

options = {
	'output':   sys.stdout,
	'filename': None,
}

formatters = {
	'text': tree_viz,
	'dot':  dot_viz,
}

def usage():
	sys.stdout.write("""usage: skosviz OPTIONS skos-file
where OPTIONS are:
    -o FILE, --output FILE     save the visualisation to FILE (or - for stdout).
    -f FORMAT, --format FORMAT the file format for the output:
        text   utf-8 encoded text [default]
        dot    graphviz graph source
""")
	sys.exit(1)

def cleanup(options):
	if options['output'] != sys.stdout:
		options['output'].close()

try:
	opt = None
	for arg in sys.argv[1:]:
		if not opt:
			if arg in ['-o', '--output']:
				opt = 'output'
			elif arg in ['-f', '--format']:
				opt = 'format'
			else:
				if options['filename'] or arg.startswith('-'):
					usage()
				options['filename'] = arg
		else:
			if opt == 'output':
				if arg != '-':
					options[opt] = codecs.open(arg, 'w', 'utf-8')
			elif opt == 'format':
				if not arg in formatters.keys():
					usage()
				options[opt] = arg
			else:
				options[opt] = arg
			opt = None

	if not options['filename']:
		usage()

	skos = parse_skos(options['filename'])
	roots = []
	for c in sorted(skos.refs.values(), key=lambda c: c.name):
		if not c.parent:
			roots.append(c)
	formatters[options['format']](skos, roots, options)
except:
	cleanup(options)
	raise
finally:
	cleanup(options)
