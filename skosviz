#!/usr/bin/python
# -*- coding: utf-8 -*-

# Copyright (C) 2011 Reece H. Dunn
#
# This file is part of skosviz.
#
# skosviz is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# skosviz is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with skosviz.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import codecs

from xml.dom import minidom

class RdfNamespace:
	def __init__(self, ns):
		self.ns = ns

	def __getattr__(self, name):
		return (self.ns, name)

rdf  = RdfNamespace('http://www.w3.org/1999/02/22-rdf-syntax-ns#')
dc   = RdfNamespace('http://purl.org/dc/elements/1.1/')
skos = RdfNamespace('http://www.w3.org/2004/02/skos/core#')

# SKOS Object Model

class ConceptBase:
	def __init__(self, name, children):
		self.name     = name
		self.children = children
		self.parent   = None

	def __str__(self):
		return self.name

class Concept(ConceptBase):
	def __init__(self, pref, alt, narrower):
		ConceptBase.__init__(self, pref, narrower)
		self.alt     = alt

	def __str__(self):
		if len(self.alt) == 0:
			return self.name
		else:
			return '%s [%s]' % (self.name, ', '.join(self.alt))

class ConceptScheme(ConceptBase):
	def __init__(self, name, top_concepts):
		ConceptBase.__init__(self, name, top_concepts)

class SkosLibrary:
	def __init__(self):
		self.concepts = {}
		self.schemes  = {}

# RDF/XML+SKOS Parser

def text(parent):
	for node in parent.childNodes:
		if node.nodeType == node.TEXT_NODE:
			return node.nodeValue
	return ''

def select(parent, ref):
	ret = []
	ns, name = ref
	for node in parent.childNodes:
		if node.nodeType == node.ELEMENT_NODE and node.localName == name and node.namespaceURI == ns:
			ret.append(node)
	return ret

def attr(parent, ref):
	ns, name = ref
	return parent.getAttributeNS(ns, name)

def getref(c):
	idref = attr(c, rdf.ID)
	if idref:
		return '#%s' % idref
	return attr(c, rdf.about)

def parseRdfXml(filename):
	ret  = SkosLibrary()
	dom  = minidom.parse(filename).documentElement
	for c in select(dom, skos.Concept):
		pref     = text(select(c, skos.prefLabel)[0])
		alt      = [text(a) for a in select(c, skos.altLabel)]
		ref      = getref(c)
		narrower = [attr(a, rdf.resource) for a in select(c, skos.narrower)]
		ret.concepts[ref] = Concept(pref, alt, narrower)
	for c in select(dom, skos.ConceptScheme):
		ref  = getref(c)
		name = text(select(c, dc.title)[0])
		top  = [attr(a, rdf.resource) for a in select(c, skos.hasTopConcept)]
		ret.schemes[ref] = ConceptScheme(name, top)
		for n in top:
			ret.concepts[n].parent = ref
	for ref, c in ret.concepts.items():
		for n in c.children:
			ret.concepts[n].parent = ref
	return ret

# Text Formatter

def tree_viz_node(c, padding, options, end):
	if end:
		branch = u'└─'
	else:
		branch = u'├─'
	options['output'].write(u'%s%s%s\n' % (padding, branch, c))

def tree_viz_impl(skos, c, padding, options, end=False):
	tree_viz_node(c, padding[:-1], options, end=end)
	padding = padding + ' '
	for i, child in enumerate(sorted(c.children, key=lambda c: skos.concepts[c].name)):
		n = skos.concepts[child]
		n.visited = True
		if len(n.children) != 0:
			if i == len(c.children)-1:
				tree_viz_impl(skos, n, padding + ' ', options, end=True)
			else:
				tree_viz_impl(skos, n, padding + u'│', options)
		else:
			tree_viz_node(n, padding, options, end=i == len(c.children)-1)

def tree_viz(skos, options):
	roots = []
	for c in sorted(skos.schemes.values(), key=lambda c: c.name):
		roots.append(c)
	for c in sorted(skos.concepts.values(), key=lambda c: c.name):
		if not c.parent:
			roots.append(c)
	for i, c in enumerate(sorted(roots, key=lambda c: c.name)):
		tree_viz_impl(skos, c, u'│', options, end=i == len(roots)-1)

# Dot Formatter

def dot_viz(skos, options):
	options['output'].write('digraph "SKOS Visualisation" {\n')
	for c in sorted(skos.schemes.values(), key=lambda c: c.name):
		options['output'].write('\t"%s"\n' % c.name)
		for i, child in enumerate(sorted(c.children, key=lambda c: skos.concepts[c].name)):
			n = skos.concepts[child]
			options['output'].write('\t"%s" -> "%s"\n' % (c.name, n.name))
	for c in sorted(skos.concepts.values(), key=lambda c: c.name):
		options['output'].write('\t"%s"\n' % c.name)
		for i, child in enumerate(sorted(c.children, key=lambda c: skos.concepts[c].name)):
			n = skos.concepts[child]
			options['output'].write('\t"%s" -> "%s"\n' % (c.name, n.name))
	options['output'].write('}\n')

# Main Program

options = {
	'output':   sys.stdout,
	'filename': None,
}

formatters = {
	'text': tree_viz,
	'dot':  dot_viz,
}

def usage():
	sys.stdout.write("""usage: skosviz OPTIONS skos-file
where OPTIONS are:
    -o FILE, --output FILE     save the visualisation to FILE (or - for stdout).
    -f FORMAT, --format FORMAT the file format for the output:
        text   utf-8 encoded text [default]
        dot    graphviz graph source
""")
	sys.exit(1)

def cleanup(options):
	if options['output'] != sys.stdout:
		options['output'].close()

try:
	opt = None
	for arg in sys.argv[1:]:
		if not opt:
			if arg in ['-o', '--output']:
				opt = 'output'
			elif arg in ['-f', '--format']:
				opt = 'format'
			else:
				if options['filename'] or arg.startswith('-'):
					usage()
				options['filename'] = arg
		else:
			if opt == 'output':
				if arg != '-':
					options[opt] = codecs.open(arg, 'w', 'utf-8')
			elif opt == 'format':
				if not arg in formatters.keys():
					usage()
				options[opt] = arg
			else:
				options[opt] = arg
			opt = None

	if not options['filename']:
		usage()

	data = parseRdfXml(options['filename'])
	formatters[options['format']](data, options)
except:
	cleanup(options)
	raise
finally:
	cleanup(options)
